## template
'''
성우는 매일 집에서 알고리즘랩스로 출근을 한다.
출근을 할 수 있는 길이 여러가지임을 깨달은 성우는, 집에서 회사까지 갈 수 있는 경로가 모두 몇 가지인지 계산해보려 한다.

성우의 집과 회사가 그려져 있는 지도는 아래 그림과 같이 직사각형으로 나타난다.
각 칸에는 1부터 200까지의 숫자가 적혀있다. 집은 항상 직사각형의 왼쪽 위에 위치하고, 알고리즘랩스는 항상 오른쪽 아래에 위치한다.

성우는 집에서 출발하며, 항상 오른쪽 또는 아래쪽으로만 이동할 수 있다.
단, 새로 이동할 칸에 적혀있는 수는 지금까지 지나온 모든 칸에 적혀있는 수와는 달라야 한다. 즉, 성우가 출근하는 경로에는 같은 숫자가 두 개 존재할 수 없다
존재하는 모든 경로 중 경로 위에 존재하는 수의 합이 가장 큰 경로를 “최대 경로” 라고 정의하자.
가로 M, 세로 N의 지도가 주어질 때 (1) 성우가 집에서 알고리즘랩스까지 갈 수 있는 경로의 수, 그리고 (2) “최대 경로” 위에 존재하는 숫자의 합을 출력하는 프로그램을 작성하시오
입력
첫째 줄에는 테스트 케이스 T (1 <= T <= 10)가 주어진다.
각 테스트 케이스에 대하여 도로의 세로의 크기 N과 가로의 크기 M (2 <= N, M <= 12)이 주어진다.
그 다음 줄부터 N개의 줄에 걸쳐, 보드에 적혀 있는 M개의 자연수가 주어지며, 이는 200 이하 자연수이다.

출력
각 테스트 케이스에 대하여 답을 출력한다.
각 줄은 “#x”, 존재하는 모든 경로의 수, “최대 경로" 위에 존재하는 숫자의 합을 공백을 사이에 두고 출력한다.
만약 집에서 알고리즘 랩스까지 경로가 하나도 존재하지 않는다면 “최대 경로”는 -1 로 출력한다.
단, x는 1부터 시작하는 테스트 케이스의 번호를 나타낸다.

예제 입력
3
6 6
1 3 1 13 7 6
17 19 2 11 1 5
5 4 3 12 2 3
6 8 7 10 7 11
10 9 15 9 3 16
11 12 13 8 17 2
6 6
1 3 1 13 7 6
1 2 2 11 1 5
5 4 3 12 2 3
6 8 7 10 7 11
10 9 4 9 3 2
11 12 13 8 6 2
2 12
11 19 3 14 10 16 6 22 35 34 27 21
25 13 30 23 18 14 8 8 7 25 12 33
예제출력
#1 8 102
#2 0 -1
#3 5 251

'''
dx = [(0, 1), (1, 0)]
def DFS(x, y, p, road):
    global cnt
    global rn
    if x == n - 1 and y == m - 1:
        rn = max(rn, p)
        cnt += 1
    else:
        for pos in dx:
            xx = pos[0] + x
            yy = pos[1] + y
            if 0 <= xx <= n - 1 and 0 <= yy <= m - 1 and res[xx][yy] not in road:
                road.append(res[xx][yy])
                DFS(xx, yy, p + res[xx][yy], road)
                road.pop()


if __name__ == '__main__':
    tas=int(input())
    for tccc in range(0,tas):
      n, m = map(int, input().split())
      res = []
      cnt = 0
      rn = 0
      for i in range(n):
          tmp = list(map(int, input().split()))
          res.append(tmp)
      a=[res[0][0]]
      DFS(0,0,res[0][0],a)

      if cnt==0:
          print("#{} {} {}".format(tccc+1,cnt, -1))
      else:
          print("#{} {} {}".format(tccc+1,cnt, rn))

